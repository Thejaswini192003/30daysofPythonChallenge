# -*- coding: utf-8 -*-
"""IDC_Python challenge.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jkuyz4K7QSImIUNFP9L2T0EXxAwvMwGz

**üêç Day 1 of Python Challenge**
"""

print("Hello World!")

print("".join(['T','H','E','J','A','S','W','I','N','I']))

N = input("enter your name: ")
print(N)

"""**üêç Day 2 of Python Challenge**"""

P= int(3.145566)
print(P)

E= float(4)
print(E)

likes_python = input("Do you like Python? (yes/no): ").lower() == "yes"
print(likes_python)

l = float(input("Enter the length of the rectangle: "))
w = float(input("Enter the width of the rectangle: "))
area = l * w
print("Area of the rectangle is:", area)

"""**üêç Day 3 of Python Challenge**"""

# Very Simple Inventory System

inventory = {}  # Empty dictionary to store items

while True:
    print("\n1. Add item")
    print("2. Show items")
    print("3. Exit")

    choice = input("Choose 1, 2 or 3: ")

    if choice == "1":
        name = input("Item name: ")
        qty = int(input("Quantity: "))

        # Add or update item
        if name in inventory:
            inventory[name] += qty
        else:
            inventory[name] = qty

        print(f"{qty} {name} added. Total now: {inventory[name]}")

    elif choice == "2":
        print("\n--- Inventory ---")
        if not inventory:
            print("No items yet.")
        else:
            for item in inventory:
                print(item, ":", inventory[item])

    elif choice == "3":
        print("Bye!")
        break

    else:
        print("Please type 1, 2 or 3.")

"""**üêç Day 4 of Python Challenge**"""

num = int(input("Enter the number: "))

# Checking for prime numbers
if num <= 1:
    print(num, "is not a prime number")
else:
    for i in range(2, num):
        if num % i == 0:
            print(num, "is not a prime number")
            break
    else:
        print(num, "is a prime number")

"""**üêç Day 5 of Python Challenge**"""

def get_sum_and_avg(nums): # with parameter with return value
    total = sum(nums)
    avg = total / len(nums) if nums else 0
    return total, avg

numbers = [float(i) for i in input("Enter the numbers separated by commas: ").split(',')]
total, avg = get_sum_and_avg(numbers)
print(f"Sum: {total}")
print(f"Average: {avg}")

"""**üêç Day 6 of Python Challenge**"""

import random
import  string #ready-made sets of characters
#Choosing the list for characters
characters = string.ascii_letters + string.digits

# Initialize the password variable as an empty string
password = ""

#generating 8-characters for password
for i in range(8):
  password += random.choice(characters)
print("Generated password:",password)

"""**üêç Day 7 of Python Challenge**"""

import csv
import string
text =input("enter your text:\n").lower()
for i in string.punctuation: text = text.replace(i," ")
words = text.split()
word_counts ={w: words.count(w) for w in set(words)}
with open('word_frequencies.csv','w',newline='') as file:
  writer = csv.writer(file)
  writer.writerow(['Word','Frequency'])
  for word,count in word_counts.items():
    writer.writerow([word,count])
print("Word frequencies saved to word_frequencies.csv")

import pandas as pd
df= pd.read_csv('word_frequencies.csv')
print(df)

"""**üêç Day 8 of Python Challenge**"""

# Define the Car class
class Car:
    # Constructor method to initialize the attributes
    def __init__(self, make, model, year, color):
        self.make = make      # Car make (e.g., Toyota)
        self.model = model    # Car model (e.g., Camry)
        self.year = year      # Manufacturing year (e.g., 2022)
        self.color = color    # Car color (e.g., Red)

    # Method to display the car details
    def display(self):
        print(f"Car Details: {self.make} {self.model} {self.year} {self.color}")

# Take input from the user for car make
make = input("Enter the car make (e.g., Toyota): ")
# Take input from the user for car model
model = input("Enter the car model (e.g., Camry): ")
# Take input from the user for manufacturing year
year = input("Enter the manufacturing year (e.g., 2022): ")
# Take input from the user for car color
color = input("Enter the car color (e.g., Red): ")

# Create an object of Car with user input
user_car = Car(make, model, year, color)

# Call the display method to show the car details
user_car.display()

"""**üêç Day 9 of Python Challenge**"""

# Base class: Car
class Car:
    def __init__(self, brand, model, year):
        self.brand = brand
        self.model = model
        self.year = year
    def show_info(self):
        return f"{self.year} {self.brand} {self.model}"
# Subclass: ElectricCar inherits from Car
class ElectricCar(Car):
    def __init__(self, brand, model, year, battery_size):
        super().__init__(brand, model, year)  # Calls the __init__ of Car
        self.battery_size = battery_size
    def show_info(self):
        return f"{self.year} {self.brand} {self.model} with {self.battery_size} kWh battery"
# Create a list of different car objects
cars = [
    Car("Toyota", "Camry", 2022),
    ElectricCar("Tesla", "Model 3", 2023, 75),
    Car("Ford", "150", 2021),
    Car("Honda", "civic",2024),
    ElectricCar("Tesla", "Model cz", 2020, 82)
]
# This demonstrates polymorphism
for vehicle in cars:
    print(vehicle.show_info())

"""**üêç Day 10 of Python Challenge**"""

# Initialize an empty list to store numbers
numbers = []
try:
    # Attempt to open the file
    file = open("/content/numbers.txt", "r")
    # Iterate through each line in the file
    for line in file:
        try:
            # Try to convert the line to a float and append to the numbers list
            # Corrected the typo 'flot' to 'float'
            numbers.append(float(line.strip()))
        except ValueError:
            # Handle cases where a line cannot be converted to a float
            # Corrected the typo 'value error' to 'ValueError'
            print("Skipping invalid", line.strip())
# Handle the case where the file is not found
# Corrected the typo 'expect file not founf error' to 'except FileNotFoundError'
except FileNotFoundError:
    print("file not found")
# This block will always execute
finally:
    try:
        # Attempt to close the file if it was opened
        # Corrected the typo 'expect' to 'except'
        file.close()
        print("file closed")
    except NameError:
        # Handle the case where 'file' was not defined (e.g., FileNotFoundError occurred)
        pass
# You can optionally print the numbers list to see what was read
print(numbers)

"""**üêç Day 11 of Python Challenge**"""

from datetime import datetime
#taking user input
date_format ="%Y-%m-%d"
d1_input = input("Enter the first date (YYYY-MM-DD):")
d2_input = input("Enter the first date (YYYY-MM-DD):")

#converting string to datetime objects
date1 = datetime.strptime(d1_input, date_format)
date2 = datetime.strptime(d2_input, date_format)

#Calculating the difference
difference =abs((date2 - date1).days)
print("days between:{difference}",difference)

"""**üêç Day 12  of Python Challenge**"""

import re
email = input("enter your email:") # user input

# Simple email regex pattern explanation:
# ^            -> Start of string
# [\w\.-]+     -> One or more word characters (a-zA-Z0-9_), dots, or hyphens
# @            -> Must contain '@'
# [\w\.-]+     -> Domain part (like gmail or yahoo)
# \.           -> A dot (.)
# \w{2,6}      -> Top-level domain like com, org, in (2 to 6 letters)
# $            -> End of string

#simple email regax pattern
pattern = r'^(?!.*\.\.)[\w.-]+@[\w.-]+\.\w{2,6}$'

if re.match(pattern,email):
  print("Valid email:",email)
else:
  print("invalid email:",email)

"""**üêç Day 13 of Python Challenge**"""

class Stack:
    def __init__(self):
        self.stack = [] # initalizing the list
    def push(self, item):       # adding the element
        self.stack.append(item)
    def pop(self):                    #removing the element from the top
        if not self.is_empty():
            return self.stack.pop()
        return "Stack is empty!"
    def peek(self):  #Preview what's on the top
        if not self.is_empty():
            return self.stack[-1]
        return "Stack is empty!"
    def is_empty(self):
        return len(self.stack) == 0
    def display(self):
        return self.stack
s = Stack()
s.push(1)
s.push(200)
s.push(345)
print("Stack:", s.display())
print("Peek:", s.peek())
print("Pop:", s.pop())
print("Stack after pop:", s.display())

"""**üêç Day 14 of Python Challenge**"""

def factorial(n):
    # Base case
    if n == 0 or n == 1:
        return 1
    # Recursive case
    else:
        return n * factorial(n - 1)

# Get input from the user
user_input = int(input("Enter a non-negative integer: "))

# Check for valid input
if user_input < 0:
    print("Factorial is not defined for negative numbers.")
else:
    result = factorial(user_input)
    print(f"The factorial of {user_input} is {result}.")

"""**üêç Day 15 of Python Challenge**"""

import time
def log_time(func):
    def wrapper():
        start = time.time()
        func()
        end = time.time()
        print("Time taken:", end - start)
    return wrapper
@log_time  # Apply the decorator to this function
def hello():
    time.sleep(1)
    print("Welcome to day 15 of üêç challenge! lets keep rocking ")

hello()

"""**üêç Day 16 of Python Challenge**"""

def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b
for num in fibonacci(10):
    print(num)

"""**üêç Day 17 of Python Challenge**"""

class SafeFileHandler:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode

    def __enter__(self):
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()


# Use the context manager here (outside the class)
with SafeFileHandler("example.txt", "w") as f:
    f.write("Hello, Welcome to 30Days Of üêç Challenge.")

"""**üêç Day 18 of Python Challenge**"""

import inspect

class MethodNameChecker(type):
    def __new__(cls, name, bases, attrs):
        # Find methods that are callable, not 'dunder' methods (like __init__),
        # and are not entirely lowercase.
        bad = [k for k, v in attrs.items()
               if callable(v) and not k.startswith('__') and k != k.lower()]
        if bad:
            raise TypeError(f"üö´ Invalid method names in '{name}': {bad}. "
                            "Method names (excluding dunder methods) must be lowercase.")
        return super().__new__(cls, name, bases, attrs)

# --- Demonstrations ---

# ‚úÖ Valid Class: Methods are all lowercase
class Good(metaclass=MethodNameChecker):
    def hello(self): pass
    def show_info(self): pass

print("‚úÖ 'Good' class defined successfully.")

# ‚ùå Invalid Class: 'Hello' method is not lowercase, will raise an error
try:
    class Bad(metaclass=MethodNameChecker):
        def Hello(self): pass # Capital 'H' causes an error
except TypeError as e:
    print(f"\nCaught expected error for 'Bad' class:\n{e}")

"""**üêç Day 19 of Python Challenge**"""

import threading
import requests
import os
# Sample list of file URLs (replace with actual URLs)
file_urls = [
    "https://colab.research.google.com/drive/1jkuyz4K7QSImIUNFP9L2T0EXxAwvMwGz?usp=sharing",
    "https://images.app.goo.gl/4VVJus4qdYCB96M19"
]
# Create a folder to save downloads
os.makedirs("downloads", exist_ok=True)
def download_file(url):
    try:
        file_name = url.split("/")[-1]
        print(f"üîÑ Downloading {file_name}...")
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        with open(f"downloads/{file_name}", "wb") as f:
            f.write(response.content)
        print(f"‚úÖ {file_name} downloaded successfully!")
    except Exception as e:
        print(f"‚ùå Failed to download {url}: {e}")
# Thread list
threads = []
for url in file_urls:
    t = threading.Thread(target=download_file, args=(url,))
    t.start()
    threads.append(t)
# Wait for all threads to complete
for t in threads:
    t.join()
print("üöÄ All downloads completed!")

"""**üêç Day 20 of Python Challenge**"""

import requests
url ="http://www.github.com"
code=requests.get(url).text
print(code)

"""**üêç Day 21 of Python Challenge**"""

import requests ## Import the necessary libraries
from bs4 import BeautifulSoup
rss_url = "http://feeds.bbci.co.uk/news/rss.xml" ## Send a GET request to the RSS feed URL
response = requests.get(rss_url) # Parse the XML content of the response using BeautifulSoup
soup = BeautifulSoup(response.content, 'xml') # Parse the XML content of the response using BeautifulSoup
titles = [item.title.text for item in soup.find_all('item')] # Parse the XML content of the response using BeautifulSoup
for i, title in enumerate(titles, 1):# Send a GET request to the RSS feed URL
    print(f"{i}. {title}")

"""**üêç Day 22 of Python Challenge**"""

import argparse  # Used to parse command-line arguments
# Function to convert temperature based on units
def convert_temp(value, from_unit, to_unit):
    from_unit = from_unit.upper()
    to_unit = to_unit.upper()
    if from_unit == to_unit:
        return value  # No conversion needed if units are the same
    # Conversion logic
    if from_unit == 'C':
        return (value * 9/5) + 32 if to_unit == 'F' else value + 273.15
    elif from_unit == 'F':
        return (value - 32) * 5/9 if to_unit == 'C' else (value - 32) * 5/9 + 273.15
    elif from_unit == 'K':
        return value - 273.15 if to_unit == 'C' else (value - 273.15) * 9/5 + 32
# Main function to handle CLI arguments and run the conversion
def main(args=None):
    # Create parser and define CLI arguments
    parser = argparse.ArgumentParser(description="Simple Temperature Converter CLI")
    parser.add_argument('--from', dest='from_unit', required=True, help='Convert from: C, F, K')
    parser.add_argument('--to', dest='to_unit', required=True, help='Convert to: C, F, K')
    parser.add_argument('--value', type=float, required=True, help='Temperature value')
    # If no args are provided (like in Colab), simulate input
    if args is None:
        args = parser.parse_args(['--from', 'C', '--to', 'F', '--value', '100'])
    else:
        args = parser.parse_args(args)
    # Perform conversion and print result
    result = convert_temp(args.value, args.from_unit, args.to_unit)
    print(f"{args.value}¬∞{args.from_unit.upper()} = {round(result, 2)}¬∞{args.to_unit.upper()}")
# Run the main function
main()

"""**üêç Day 23 of Python Challenge**"""

import ipywidgets as widgets
from IPython.display import display
temp = widgets.FloatText(description='Temp:')
convert_type = widgets.Dropdown(options=["C‚ÜíF", "F‚ÜíC"], description='Convert:')
output = widgets.Label()
def convert_temp(change):
    t = temp.value
    if convert_type.value == "C‚ÜíF":
        result = (t * 9/5) + 32
    else:
        result = (t - 32) * 5/9
    output.value = f"Result: {round(result, 2)}"
convert_type.observe(convert_temp, names='value')
temp.observe(convert_temp, names='value')
display(temp, convert_type, output)

"""**üêç Day 24 of Python Challenge**"""

from dataclasses import dataclass

@dataclass
class Book:
    title: str
    author: str
    isbn: str
    publication_year: int = 2024  # default value if not provided

    def display_details(self) -> str:
        return (
            f"üìñ Book Details:\n"
            f"‚Ä¢ Title: {self.title}\n"
            f"‚Ä¢ Author: {self.author}\n"
            f"‚Ä¢ ISBN: {self.isbn}\n"
            f"‚Ä¢ Published: {self.publication_year}"
        )

# Creating an instance for "The Unposted Letter"
book2 = Book(
    title="The Unposted Letter",
    author="Mahatria Ra",
    isbn="9788189988949",
    publication_year=2010
)

# Display book details
print(book2.display_details())

"""**üêç Day 25 of Python Challenge**"""

!pip install pydantic[email]

from pydantic import BaseModel, EmailStr, Field, ValidationError

class UserProfile(BaseModel):
    name: str
    email: EmailStr
    age: int = Field(..., ge=18, le=100)
# Get user input
name = input("Enter your name: ")
email = input("Enter your email: ")
age = input("Enter your age: ")
try:
    user = UserProfile(name=name, email=email, age=int(age))
    print("\n‚úÖ User profile created successfully!")
    print(user)
except ValidationError as e:
    print("\n‚ùå Validation error:")
    print(e)

"""**üêç Day 26 of Python Challenge**"""

!pip install gradio
import gradio as gr
# In-memory book list
books = []
# Add Book
def add_book(title, author, year):
    book = {"title": title, "author": author, "year": year}
    books.append(book)
    return books
# View Books
def get_books():
    return books
# UI
with gr.Blocks() as demo:
    gr.Markdown("üìö **Simple Book Library**")
    with gr.Row():
        title = gr.Textbox(label="Book Title")
        author = gr.Textbox(label="Author")
        year = gr.Number(label="Year")
    add_btn = gr.Button("‚ûï Add Book")
    output = gr.JSON()
    add_btn.click(fn=add_book, inputs=[title, author, year], outputs=output)
    gr.Markdown("üìñ **Current Library**")
    show_btn = gr.Button("üìö Show All Books")
    output_all = gr.JSON()
    show_btn.click(fn=get_books, outputs=output_all)
demo.launch()

"""**üêç Day 27 of Python Challenge**"""

!pip install gradio sqlalchemy

# üì¶ Install dependencies
!pip install -q gradio sqlalchemy
# üìö Imports
import gradio as gr
from sqlalchemy import Column, Integer, String, create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
# üõ†Ô∏è DB Setup
DATABASE_URL = "sqlite:///books.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()
# üìñ Book Model
class Book(Base):
    __tablename__ = "books"
    id = Column(Integer, primary_key=True)
    title = Column(String)
    author = Column(String)
    description = Column(String)
Base.metadata.create_all(bind=engine)
# ‚öôÔ∏è CRUD Functions
def add_book(title, author, description):
    db = SessionLocal()
    new_book = Book(title=title, author=author, description=description)
    db.add(new_book)
    db.commit()
    db.close()
    return f"‚úÖ Book '{title}' added!"
def get_books():
    db = SessionLocal()
    books = db.query(Book).all()
    db.close()
    return "\n".join([f"{b.id}. {b.title} by {b.author}" for b in books]) or "No books yet!"
def delete_book(book_id):
    db = SessionLocal()
    book = db.query(Book).filter(Book.id == int(book_id)).first()
    if book:
        db.delete(book)
        db.commit()
        msg = f"üóëÔ∏è Deleted Book ID {book_id}"
    else:
        msg = f"‚ùå Book ID {book_id} not found"
    db.close()
    return msg
# üé® Gradio Interface
with gr.Blocks() as demo:
    gr.Markdown("# üìö Book Manager")
    with gr.Row():
        title = gr.Textbox(label="Title")
        author = gr.Textbox(label="Author")
        description = gr.Textbox(label="Description")
        add_btn = gr.Button("Add Book")
    output_add = gr.Textbox(label="Status")
    add_btn.click(fn=add_book, inputs=[title, author, description], outputs=output_add)
    with gr.Row():
        get_btn = gr.Button("üìñ Show All Books")
        delete_id = gr.Number(label="Book ID to Delete", precision=0)
        delete_btn = gr.Button("üóëÔ∏è Delete Book")
    output_books = gr.Textbox(label="Books List")
    output_delete = gr.Textbox(label="Delete Status")
    get_btn.click(fn=get_books, inputs=[], outputs=output_books)
    delete_btn.click(fn=delete_book, inputs=[delete_id], outputs=output_delete)
# üöÄ Launch
demo.launch(share=True)

"""**üêç Day 28 of Python Challenge**"""

from typing import List
class Task:
    def __init__(self, description: str):
        self.description = description
        self.completed = False
    def mark_done(self):
        self.completed = True
    def __str__(self):
        status = "‚úÖ" if self.completed else "üïì"
        return f"{status} {self.description}"
class TodoManager:
    def __init__(self):
        self.tasks: List[Task] = []

    def add_task(self, description: str):
        task = Task(description)
        self.tasks.append(task)
        print(f"‚ûï Task added: {description}")
    def view_tasks(self):
        if not self.tasks:
            print("üì≠ No tasks yet!")
            return
        print("\nüìù Your To-Do List:")
        for index, task in enumerate(self.tasks, start=1):
            print(f"{index}. {task}")
    def mark_task_done(self, index: int):
        if 0 <= index < len(self.tasks):
            self.tasks[index].mark_done()
            print(f"‚úÖ Task marked as done: {self.tasks[index].description}")
        else:
            print("‚ùå Invalid task number.")
def main():
    todo = TodoManager()
    while True:
        print("\n--- To-Do Manager ---")
        print("1. Add Task")
        print("2. View Tasks")
        print("3. Mark Task as Done")
        print("4. Exit")
        choice = input("Enter your choice (1‚Äì4): ")
        if choice == '1':
            description = input("Enter task description: ").strip()
            todo.add_task(description)
        elif choice == '2':
            todo.view_tasks()
        elif choice == '3':
            try:
                index = int(input("Enter task number to mark as done: ")) - 1
                todo.mark_task_done(index)
            except ValueError:
                print("‚ùå Please enter a valid number.")
        elif choice == '4':
            print("üëã Stay productive!")
            break
        else:
            print("‚ùå Invalid choice. Try again.")
if __name__ == "__main__":
    main()