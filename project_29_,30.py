# -*- coding: utf-8 -*-
"""Project 29 ,30

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ccBCqTVqpOT3m4-a_YdHxuZLTBknBkXa

**main.py**
"""

from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from extract import extract_text
from analyzer import clean_text, split_into_sections, analyze_against_jd
from generate_report import create_pdf_report
import os  # ‚úÖ Needed for opening the PDF

class ResumeApp(BoxLayout):
    def process_resume(self):
        filechooser = self.ids.filechooser
        jd_input = self.ids.jd_input
        selected_label = self.ids.selected_file_label
        name_input = self.ids.name_input
        role_input = self.ids.role_input

        selected_file = filechooser.selection
        job_description = jd_input.text.strip()
        candidate_name = name_input.text.strip()
        job_role = role_input.text.strip()

        if not selected_file:
            selected_label.text = "‚ùå No file selected!"
            return
        if not job_description:
            selected_label.text = "‚ùå Please enter job description!"
            return
        if not candidate_name or not job_role:
            selected_label.text = "‚ùå Please enter candidate name and job role!"
            return

        try:
            resume_text = extract_text(selected_file[0])
            cleaned_text = clean_text(resume_text)
            sections = split_into_sections(cleaned_text)
            report = analyze_against_jd(cleaned_text, job_description)

            print("\n‚úÖ Summary:\n", sections.get("summary", "Not found"))
            print("\nüß† Skills:\n", sections.get("skills", "Not found"))
            print("\nüìä Report:\n", report)

            # ‚úÖ Save PDF and remember the path
            self.generated_report_path = create_pdf_report(
                candidate_name=candidate_name,
                job_role=job_role,
                report_data=report
            )

            selected_label.text = " Resume processed & PDF generated!"

        except Exception as e:
            selected_label.text = f"Error: {e}"

    # ‚úÖ Add this method to support the "Download" button
    def download_report(self):
        try:
            if hasattr(self, 'generated_report_path') and os.path.exists(self.generated_report_path):
                os.startfile(self.generated_report_path)  # ‚úÖ Windows-specific
            else:
                print(" PDF not found. Please generate it first.")
        except Exception as e:
            print(f" Error opening report: {e}")

class ResumeAnalyzerApp(App):
    def build(self):
        return ResumeApp()

if __name__ == "__main__":
    ResumeAnalyzerApp().run()

"""**extract.py**"""

import os
from PyPDF2 import PdfReader
from docx import Document

def extract_text(file_path):
    ext = os.path.splitext(file_path)[1].lower()
    if ext == ".pdf":
        return extract_text_from_pdf(file_path)
    elif ext == ".docx":
        return extract_text_from_docx(file_path)
    else:
        raise ValueError("Unsupported file type. Only PDF and DOCX are supported")

def extract_text_from_pdf(file_path):
    reader = PdfReader(file_path)
    text = ''
    for page in reader.pages:
        page_text = page.extract_text()
        if page_text:
            text += page_text + '\n'
    return text.strip()

def extract_text_from_docx(file_path):
    doc = Document(file_path)
    text = '\n'.join([para.text for para in doc.paragraphs])
    return text.strip()

"""**analyzer.py**"""

import re

# ‚úÖ Clean the resume text
def clean_text(raw_text):
    raw_text = raw_text.lower()
    raw_text = re.sub(r"[^a-z0-9\s.,;:()/\u2013\-/]", "", raw_text)  # keep / and ‚Äì (en dash)
    raw_text = re.sub(r"\s+", " ", raw_text).strip()
    return raw_text

# ‚úÖ Split into logical sections (optional for scoring)
def split_into_sections(cleaned_text):
    section_patterns = {
        'summary': r'(summary|profile|objective)',
        'skills': r'(skills|technical skills)',
        'education': r'(education|academic background)',
        'work_experience': r'(work experience|professional experience)',
        'certifications': r'(certifications|licenses|awards)'
    }

    section_positions = {}
    for key, pattern in section_patterns.items():
        match = re.search(rf'{pattern}\s*[:\-]', cleaned_text, re.IGNORECASE)
        if match:
            section_positions[key] = match.start()

    sorted_sections = sorted(section_positions.items(), key=lambda x: x[1])
    sections = {}

    for i, (section, start) in enumerate(sorted_sections):
        end = sorted_sections[i + 1][1] if i + 1 < len(sorted_sections) else len(cleaned_text)
        sections[section] = cleaned_text[start:end].strip()

    return sections

# ‚úÖ Analyze cleaned resume vs job description
def analyze_against_jd(cleaned_resume, job_description):
    job_description = job_description.lower()
    resume_text = cleaned_resume.lower()

    # üéØ Valid skills list (lowercase comparison used)
    valid_skills = {
        "excel", "sql", "mysql", "postgresql", "sqlite", "mongodb", "power bi", "tableau", "looker",
        "superset", "aws", "azure", "gcp", "databricks", "snowflake", "bigquery", "google sheets",
        "python", "r", "sas", "julia", "shell", "bash", "java", "scala", "javascript",
        "pandas", "numpy", "matplotlib", "seaborn", "plotly", "scikit-learn", "tensorflow", "keras",
        "pytorch", "statsmodels", "xgboost", "lightgbm", "nltk", "spacy", "opencv", "pyspark",
        "beautifulsoup", "requests", "fastapi", "flask",
        "data cleaning", "data preprocessing", "data wrangling", "data mining", "data visualization",
        "data modeling", "feature engineering", "feature selection", "dimensionality reduction", "data structures",
        "eda", "etl", "elt", "dashboarding", "a/b testing", "data pipelines", "data governance", "data quality",
        "data lake", "data warehouse", "machine learning", "supervised learning", "unsupervised learning",
        "reinforcement learning", "regression", "classification", "clustering", "decision trees", "random forest",
        "svm", "neural networks", "deep learning", "nlp", "time series", "forecasting", "recommendation system",
        "model deployment", "hyperparameter tuning", "model evaluation", "cross validation",
        "business intelligence", "storytelling", "communication", "problem solving", "presentation", "agile",
        "scrum", "jira", "business acumen", "critical thinking", "stakeholder management", "collaboration"
    }

    # ‚úÖ Extract JD keywords and filter with valid skills
    jd_keywords = set(re.findall(r'\b[a-z]{3,}\b', job_description))  # only words with 3+ chars
    keywords = [kw for kw in jd_keywords if kw in valid_skills]

    # ‚úÖ Match keywords in resume
    matched_keywords = [kw for kw in keywords if re.search(r'\b' + re.escape(kw) + r'\b', resume_text)]
    keyword_score = int((len(matched_keywords) / len(keywords)) * 100) if keywords else 0

    # ‚úÖ Formatting score based on sections
    section_count = len(re.findall(r'(summary|skills|education|work experience|certifications)', resume_text))
    format_score = min(section_count / 5 * 100, 100)

    # ‚úÖ Combine for overall score
    overall_score = int((keyword_score * 0.6) + (format_score * 0.4))

    # ‚úÖ Missing keywords
    missing_keywords = sorted(set(keywords) - set(matched_keywords))

    # ‚úÖ Suggestions
    suggestions = []
    if missing_keywords:
        suggestions.append("Add missing keywords: " + ", ".join(missing_keywords))
    if section_count < 3:
        suggestions.append("Add more resume sections (e.g., Skills, Work Experience).")

    # ‚úÖ Return final report
    return {
        "keyword_score": keyword_score,
        "format_score": format_score,
        "overall_score": overall_score,
        "missing_keywords": missing_keywords,
        "suggestions": suggestions
    }

"""**generate_report.py**"""

from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from reportlab.lib import colors
from datetime import datetime
import matplotlib.pyplot as plt
import os
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont

# Register fonts
pdfmetrics.registerFont(TTFont('Arial', 'arial.ttf'))
pdfmetrics.registerFont(TTFont('Arial-Bold', 'arialbd.ttf'))

def create_pdf_report(candidate_name, job_role, report_data):
    # === PIE CHART SETUP ===
    total = report_data["keyword_score"] + len(report_data["missing_keywords"])
    matched = int((report_data["keyword_score"] / 100) * total)
    missing = total - matched if total else 0

    labels = ['Matched', 'Missing']
    sizes = [matched, missing]
    pie_colors = ['#00FFF7', '#FF00A8']

    fig, ax = plt.subplots(figsize=(3.5, 3.5), subplot_kw=dict(aspect="equal"))
    wedges, texts, autotexts = ax.pie(
        sizes,
        labels=labels,
        autopct='%1.1f%%',
        startangle=90,
        colors=pie_colors,
        textprops=dict(color="black", fontsize=10)
    )
    ax.set_title("Keyword Match", color="black", fontsize=12, fontweight='bold')
    pie_path = "pie_chart_v2.png"
    plt.savefig(pie_path, bbox_inches='tight')
    plt.close()

    # === PDF GENERATION ===
    pdf_path = "resume_feedback_report_v2.pdf"
    c = canvas.Canvas(pdf_path, pagesize=A4)
    width, height = A4

    # Set Title
    c.setFont("Arial-Bold", 22)
    c.setFillColor(colors.black)
    c.drawCentredString(width / 2, height - 50, "Resume Feedback Report")

    # Candidate Info
    c.setFont("Arial", 12)
    c.drawString(50, height - 90, f"Candidate Name: {candidate_name}")
    c.drawString(50, height - 110, f"Target Role: {job_role}")
    c.drawString(50, height - 130, f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

    # Draw Pie Chart (Right side)
    c.drawImage(pie_path, width - 220, height - 300, width=160, preserveAspectRatio=True)

    # Scores Section
    y = height - 170
    c.setFont("Arial-Bold", 14)
    c.drawString(50, y, "Scores")
    y -= 20
    c.setFont("Arial", 12)

    ks = report_data["keyword_score"]
    fs = report_data["format_score"]
    oscore = report_data["overall_score"]

    c.setFillColor(colors.red if ks < 65 else colors.black)
    c.drawString(60, y, f"Keyword Score: {ks}%")
    y -= 20
    c.setFillColor(colors.black)
    c.drawString(60, y, f"Format Score: {fs:.1f}%")
    y -= 20
    c.setFillColor(colors.red if oscore < 65 else colors.black)
    c.drawString(60, y, f"Overall Score: {oscore}%")
    c.setFillColor(colors.black)

    # === MISSING KEYWORDS ===
    y -= 40
    c.setFont("Arial-Bold", 14)
    c.drawString(50, y, "Missing Keywords")
    y -= 20
    c.setFont("Arial", 12)
    for kw in report_data["missing_keywords"]:
        if y < 80:
            c.showPage()
            y = height - 50
        c.drawString(65, y, f"‚Ä¢ {kw}")
        y -= 18

    # === SUGGESTIONS ===
    y -= 20
    c.setFont("Arial-Bold", 14)
    c.drawString(50, y, "Suggestions")
    y -= 20
    c.setFont("Arial", 12)
    for s in report_data["suggestions"]:
        if y < 80:
            c.showPage()
            y = height - 50
        c.drawString(65, y, f"- {s}")
        y -= 18

    c.save()
    print(f" PDF report saved as: {pdf_path}")
    return pdf_path

"""**resumeanalyzer.kv**"""

<ResumeApp>:
    orientation: 'vertical'
    padding: 10
    spacing: 5

    Label:
        text: "Select a resume file:"
        size_hint_y: None
        height: 30

    FileChooserIconView:
        id: filechooser
        filters: ['*.pdf', '*.docx']
        size_hint_y: 0.5
        on_selection: selected_file_label.text = ("[color=00ff00][b] Selected: " + self.selection[0].split("/")[-1] + "[/b][/color]") if self.selection else "No file selected"

    Label:
        id: selected_file_label
        text: "No file selected"
        markup: True
        size_hint_y: None
        height: 25

    Label:
        text: "[b]Candidate Name:[/b]"
        markup: True
        size_hint_y: None
        height: 25

    TextInput:
        id: name_input
        hint_text: "Enter Candidate Name"
        multiline: False
        size_hint_y: None
        height: 40

    Label:
        text: "[b]Target Job Role:[/b]"
        markup: True
        size_hint_y: None
        height: 25

    TextInput:
        id: role_input
        hint_text: "Enter Job Role (e.g., Data Analyst)"
        multiline: False
        size_hint_y: None
        height: 40

    Label:
        text: "[b]Paste the Job Description below:[/b]"
        markup: True
        size_hint_y: None
        height: 25

    TextInput:
        id: jd_input
        hint_text: "Enter job description here..."
        multiline: True
        size_hint_y: 0.2

    Button:
        text: "Process Resume"
        size_hint_y: None
        height: 50
        background_color: 0, 0.3, 0.6, 1
        on_press: root.process_resume()

    Button:
        text: "Download Feedback Report"
        size_hint_y: None
        height: 50
        background_color: 0, 0.6, 0.3, 1
        on_press: root.download_report()